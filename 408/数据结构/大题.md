# 总览

## 算法题
[2009 链表](#2009_1)  
[2010 顺序表](#2010_1)  
[2011 顺序表](#2011_1)  
[2012 链表](#2012_1)  
[2013 顺序表](#2013_1)  
[2014 二叉树遍历](#2014_1)  
[2015 链表](#2015_1)  
[2016 交换排序](#2016_1)  
[2017 二叉树遍历](#2017_1)  
[2018 顺序表](#2018_1)  
[2019 链表](#2019_1)  
[2020 顺序表](#2020_1)  
[2021 图的存储](#2021_1)  
[2022 二叉树遍历](#2022_1)  
[2023 图的存储](#2023_1)  
[2024 图的应用](#2024_1)  

## 应用题
[2009 图的应用](#2009_2)  
[2010 散列表](#2010_2)  
[2011 图的应用](#2011_2)  
[2012 树的应用](#2012_2)  
[2013 顺序查找](#2013_2)  
[2014 图的应用](#2014_2)  
[2015 图的存储](#2015_2)  
[2016 二叉树概念](#2016_2)  
[2017 图的应用](#2017_2)  
[2018 图的应用](#2018_2)  
[2019 队列](#2019_2)  
[2020 树的应用](#2020_2)  
[2021 归并/基数/计数排序](#2021_2)  
[2022 选择排序](#2022_2)  
[2023 外部排序](#2023_2)  
[2024 散列表](#2024_2)  

## 2009

算法题：[链表](#2009_1) 
应用题：[图的应用](#2009_2)

## 2010
算法题：[顺序表](#2010_1) 
应用题：[散列表](#2010_2)

## 2011
算法题：[顺序表](#2011_1) 
应用题：[图的应用](#2011_2)

## 2012
算法题：[链表](#2012_1) 
应用题：[树的应用](#2012_2)

## 2013
算法题：[顺序表](#2013_1) 
应用题：[顺序查找](#2013_2)

## 2014
算法题：[二叉树遍历](#2014_1) 
应用题：[图的应用](#2014_2)

## 2015
算法题：[链表](#2015_1) 
应用题：[图的存储](#2015_2)

## 2016
算法题：[交换排序](#2016_1) 
应用题：[二叉树概念](#2016_2)

## 2017
算法题：[二叉树遍历](#2017_1) 
应用题：[图的应用](#2017_2)

## 2018
算法题：[顺序表](#2018_1) 
应用题：[图的应用](#2018_2)

## 2019
算法题：[链表](#2019_1) 
应用题：[队列](#2019_2)  

## 2020
算法题：[顺序表](#2020_1) 
应用题：[树的应用](#2020_2)

## 2021
算法题：[图的存储](#2021_1) 
应用题：[归并/基数/计数排序](#2021_2)

## 2022
算法题： [二叉树遍历](#2022_1)
应用题： [选择排序](#2022_2) 

## 2023

算法题：[图的存储](#2023_1) 
应用题：[外部排序](#2023_2)

## 2024
算法题：[图的应用](#2024_1) 
应用题：[散列表](#2024_2)



# 线性表——顺序表示

## 1.<a id="2010_1"></a>

![image-20251127215334872](大题.assets/image-20251127215334872.png)

![image-20251127220045842](大题.assets/image-20251127220045842.png)

![image-20251127220100193](大题.assets/image-20251127220100193.png)

### 注意：使用倒转的方法进行三次循环，或者更易想到的是借助辅助数组

## 2.<a id="2011_1"></a>

![image-20251127215344736](大题.assets/image-20251127215344736.png)

![image-20251127215400600](大题.assets/image-20251127215400600.png)

![image-20251127220116370](大题.assets/image-20251127220116370.png)

![image-20251127220131506](大题.assets/image-20251127220131506.png)

### 注意：另解更易想到，但时间复杂度会高一点为O（n）

## 3.<a id="2013_1"></a>

![image-20251127215419644](大题.assets/image-20251127215419644.png)

![image-20251127220147241](大题.assets/image-20251127220147241.png)

![image-20251127220158088](大题.assets/image-20251127220158088.png)

### 注意：经典算法，但不需要死磕最优解

## 4.<a id="2018_1"></a>

![image-20251127215438409](大题.assets/image-20251127215438409.png)

![image-20251127220223636](大题.assets/image-20251127220223636.png)

### 注意：观察要求是在空间上最优还是时间上最优，这道题运用了桶排序的思想

## 5.<a id="2020_1"></a>

![image-20251127215452415](大题.assets/image-20251127215452415.png)

![image-20251127220234733](大题.assets/image-20251127220234733.png)

![image-20251127220252537](大题.assets/image-20251127220252537.png)

![image-20251127220303515](大题.assets/image-20251127220303515.png)

### 注意：具体问题具体分析，转换为已知的问题，化繁为简

# 线性表——链式表示

## 1.<a id="2009_1"></a>

![image-20251127215554784](大题.assets/image-20251127215554784.png)

![image-20251127220339715](大题.assets/image-20251127220339715.png)

![image-20251127220349328](大题.assets/image-20251127220349328.png)

### 注意：快慢指针

## 2.<a id="2012_1"></a>

![image-20251127215622462](大题.assets/image-20251127215622462.png)

![image-20251127220419429](大题.assets/image-20251127220419429.png)

![image-20251127220439120](大题.assets/image-20251127220439120.png)

### 注意：还是快慢指针，或者使用头插法倒置，寻找到第一个下一位指针不同的节点即为所求节点，但这会破坏链表，时间复杂度一致

## 3.<a id="2015_1"></a>

![image-20251127215636417](大题.assets/image-20251127215636417.png)

![image-20251127220453509](大题.assets/image-20251127220453509.png)

![image-20251127220510265](大题.assets/image-20251127220510265.png)

### 注意：使用辅助数组记录是否出现过，进行时间上的优化

## 4.<a id="2019_1"></a>

![image-20251127215647853](大题.assets/image-20251127215647853.png)

![image-20251127220537360](大题.assets/image-20251127220537360.png)

![image-20251127220546935](大题.assets/image-20251127220546935.png)

### 注意：快慢指针（确定中间节点）+倒排（使用了头插法）+交错遍历合并链表

倒排过程中可以将p看成头指针，r是暂存指针，q->next = p->next;是将对象指针插到头节点之后（即该链表的最前面）；p->next = q;是重新确定头指针

交错遍历合并链表过程中q->next = s->next;是将q节点放到s节点的下一节点之前，s->next = q;是将s放到q之前

# 队列

## 1.<a id="2019_2"></a>

![image-20251127232334702](大题.assets/image-20251127232334702.png)

![image-20251129201126115](大题.assets/image-20251129201126115.png)

### 注意：循环队列

# 树与二叉树——二叉树的概念

## 1.<a id="2016_2"></a>

![image-20251127215928248](大题.assets/image-20251127215928248.png)

![image-20251127215948534](大题.assets/image-20251127215948534.png)

### 注意：

（1）有m个非叶节点，那么就有mk个由非叶节点的孩子，去除掉非叶节点（根节点除外，除了根节点外其他非叶节点也是非叶节点的孩子节点）（m-1），即为叶节点

# 树与二叉树——二叉树的遍历与线索二叉树

## 1.<a id="2014_1"></a>

![image-20251127220646163](大题.assets/image-20251127220646163.png)

![image-20251127220854983](大题.assets/image-20251127220854983.png)

![image-20251127220911281](大题.assets/image-20251127220911281.png)

### 注意：两种方法计算WPL

## 2.<a id="2017_1"></a>

![image-20251127220729119](大题.assets/image-20251127220729119.png)

![image-20251127220930604](大题.assets/image-20251127220930604.png)

![image-20251127220952698](大题.assets/image-20251127220952698.png)

### 注意：中序遍历的变式

## 3.<a id="2022_1"></a>

![image-20251127220741858](大题.assets/image-20251127220741858.png)

![image-20251127220752566](大题.assets/image-20251127220752566.png)

![image-20251127221007382](大题.assets/image-20251127221007382.png)

![image-20251127221016633](大题.assets/image-20251127221016633.png)

![image-20251127221026324](大题.assets/image-20251127221026324.png)

### 注意：！！

解法一的优化版：

二叉搜索树需要满足的条件是：任一结点值大于其左子树中的全部结点值，小于其右子树中的全部结点值。中序遍历二叉搜索树得到一个升序序列。

使用整型变量 `val` 记录中序遍历过程中已遍历结点的最大值，初值为一个负整数，对二叉树进行[中序遍历](https://www.csgraduates.com/data_structure/tree/btree/#中序遍历)。若当前遍历的结点值小于等于 `val`，则算法返回 false，否则，将 `val` 的值更新为当前结点的值。

2）算法实现

```c
// val 存储中序遍历中访问到的最大值
// 返回值：当前子树是否为 BST
bool solve(SqBiTree *tree, int k, int *val) {
  if (k >= tree->ElemNum) {
    // 空结点
    return true;
  }
  // 判断左子树是否为 BST
  bool ret = solve(tree, 2*k+1, val);
  if (!ret) {
    return false;
  }
  int cur_val = tree->SqbiTNode[k];
  if (cur_val == -1) {
    // 空结点
    return true;
  }
  // 判断中序序列是否递增
  if (cur_val > *val) {
    *val = cur_val;
  } else {
    return false;
  }
  // 判断右子树是否为 BST
  ret = solve(tree, 2*k+2, val);
  if (!ret) {
    return false;
  }
  return true;
}
```

# 树与二叉树——树的应用

## 1.<a id="2012_2"></a>

![image-20251127223152405](大题.assets/image-20251127223152405.png)

![image-20251127223221901](大题.assets/image-20251127223221901.png)

![image-20251127223256767](大题.assets/image-20251127223256767.png)

### 注意：（1）

## 2.<a id="2020_2"></a>

![image-20251127223202569](大题.assets/image-20251127223202569.png)

![image-20251127223319134](大题.assets/image-20251127223319134.png)

![image-20251127223327108](大题.assets/image-20251127223327108.png)

### 注意：（1）（3）

# 图——图的存储与基本操作

## 1.<a id="2015_2"></a>

![image-20251127221140640](大题.assets/image-20251127221140640.png)

![image-20251127221308928](大题.assets/image-20251127221308928.png)

![image-20251127221328898](大题.assets/image-20251127221328898.png)

## 2.<a id="2021_1"></a>

![image-20251127221152785](大题.assets/image-20251127221152785.png)

![image-20251127221344071](大题.assets/image-20251127221344071.png)



## 3.<a id="2023_1"></a>

![image-20251127221217454](大题.assets/image-20251127221217454.png)

![image-20251127221356497](大题.assets/image-20251127221356497.png)

![image-20251127221406589](大题.assets/image-20251127221406589.png)

# 图——图的应用

## 1.<a id="2009_2"></a>

![image-20251127221539826](大题.assets/image-20251127221539826.png)

![image-20251127221754713](大题.assets/image-20251127221754713.png)

## 2.<a id="2011_2"></a>

![image-20251127221553123](大题.assets/image-20251127221553123.png)

![image-20251127221810433](大题.assets/image-20251127221810433.png)

![image-20251127221841993](大题.assets/image-20251127221841993.png)

![image-20251127221901655](大题.assets/image-20251127221901655.png)

### 注意：（1）（3）关键路径的求法和暴力枚举

## 3.<a id="2014_2"></a>

![image-20251127221608277](大题.assets/image-20251127221608277.png)

![image-20251127221620407](大题.assets/image-20251127221620407.png)

![image-20251127221917595](大题.assets/image-20251127221917595.png)

![image-20251127221932152](大题.assets/image-20251127221932152.png)

![image-20251127221946187](大题.assets/image-20251127221946187.png)

![image-20251127221956104](大题.assets/image-20251127221956104.png)



### 注意：计算机网络与数据结构融合

## 4.<a id="2017_2"></a>

![image-20251127221635509](大题.assets/image-20251127221635509.png)

![image-20251127222013121](大题.assets/image-20251127222013121.png)

### 注意：（2）

## 5.<a id="2018_2"></a>

![image-20251127221649089](大题.assets/image-20251127221649089.png)

![image-20251127222023551](大题.assets/image-20251127222023551.png)

### 注意：（1）（3）

## 6.<a id="2024_1"></a>

![image-20251127221704025](大题.assets/image-20251127221704025.png)

![image-20251127221712791](大题.assets/image-20251127221712791.png)

![image-20251127221721189](大题.assets/image-20251127221721189.png)

![image-20251127222110600](大题.assets/image-20251127222110600.png)

![image-20251127222120353](大题.assets/image-20251127222120353.png)

### 注意：拓朴排序是否唯一

# 查找——顺序查找和折半查找

## 1.<a id="2013_2"></a>

![image-20251127222232023](大题.assets/image-20251127222232023.png)

![image-20251127222300230](大题.assets/image-20251127222300230.png)

### 注意：（2）



# 查找——散列表

## 1.<a id="2010_2"></a>

![image-20251127223542005](大题.assets/image-20251127223542005.png)

![image-20251127223611604](大题.assets/image-20251127223611604.png)

### 注意：（1）的装填因子（2）的查找失败次数

## 2.<a id="2024_2"></a>

![image-20251127223554194](大题.assets/image-20251127223554194.png)

![image-20251127223622645](大题.assets/image-20251127223622645.png)

![image-20251127223631743](大题.assets/image-20251127223631743.png)

# 排序——交换排序

## 1.<a id="2016_1"></a>

![image-20251127222357359](大题.assets/image-20251127222357359.png)

![image-20251127222406096](大题.assets/image-20251127222406096.png)

![image-20251127222452180](大题.assets/image-20251127222452180.png)

![image-20251127222503209](大题.assets/image-20251127222503209.png)

### 注意：快速排序

# 排序——选择排序

## 1.<a id="2022_2"></a>

![image-20251127222541583](大题.assets/image-20251127222541583.png)

![image-20251127222607817](大题.assets/image-20251127222607817.png)

### 注意：即维护一个当前状态下满足条件的数据结构

# 排序——归并排序，基数排序，计数排序

## 1.<a id="2021_2"></a>

![image-20251127222710113](大题.assets/image-20251127222710113.png)

![image-20251127222719190](大题.assets/image-20251127222719190.png)

![image-20251130215556022](大题.assets/image-20251130215556022.png)

### 注意：分析（3）

# 排序——外部排序

## 1.<a id="2023_2"></a>

![image-20251127222754842](大题.assets/image-20251127222754842.png)

![image-20251127222803157](大题.assets/image-20251127222803157.png)

![image-20251127222839450](大题.assets/image-20251127222839450.png)

![image-20251127222849360](大题.assets/image-20251127222849360.png)

### 注意
